
<html>
<style>
  code {
    display: block;
    white-space: pre-wrap
  }
</style>

<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>SQL and Databases</title>

    <link href="../lib/bootstrap/dist/css/bootstrap.min.css" rel="stylesheet">
    <link href="../css/article-regex.css" rel="stylesheet">
    <link href="../css/article-header.css" rel="stylesheet">
    <link href="../css/article-navbar.css" rel="stylesheet">
    <link href="../css/article.css" rel="stylesheet">
    <link href="../css/fonts.css" rel="stylesheet">
</head>

<body>
  <nav class="article-header">
      <a href="../index.html">HOME</a>
      <a>&bull;</a>
      <a href="">ABOUT</a>
      <a>&bull;</a>
      <a href="article-intro.html">DSL</a>
      <a>&bull;</a>
      <a href="article-regex.html">REGEX</a>
      <a>&bull;</a>
      <a href="">SQL</a>
      <a>&bull;</a>
      <a href="matlab.html">MATLAB</a>
  </nav>
  <div class="banner-div">
    <img class="banner-image" src="../img/sql.png">
  </div>
 <div class="article-container shift-down-for-header">
      <div class="row">
        <div class="col-2">
          <nav id="article-nav" class="nav nav-pills flex-column">
            <a class="nav-link" href="#introduction">Introduction</a>
            <a class="nav-link" href="#structuredifferences">Structure Differences</a>
            <a class="nav-link" href="#sqlvsjpql">SQL vs JPQL</a>
            <a class="nav-link" href="#bigdata">Big Data</a>
          </nav>
        </div>
        <div data-spy="scroll" data-target="#article-nav" class="col-8">
        <div id = "introduction">
          <h2>SQL and Databases</h2>
          <h2 id="para-1">Introduction</h2>
          <p>
            SQL was developed as a Domain Specific Language (DSL) to handle large amounts of relational data quickly and effectively.
            It was first used at IBM to manipulate System R in 1970s and its use has significantly grown over the years. Due
            to the variability of generic multipurpose languages, they may not have the optimal algorithms for processing this
            type of data in such large quantities. SQL still has the main feature of other programming languages, but it has
            aspects that directly promote the purpose of the language such as being easily transferable between operating systems.
            In addition, its syntax is relatively straightforward and so can be interpreted easily by its operators.
          </p>
        </div>

        <div style="margin-bottom: 50px; margin-top: 50px;">
          <img src="../img/sql_1.png" style="display: block; margin-right: auto; margin-left: auto;">
        </div>

        <div id = "structuredifferences">

        <h2 id="para-2">Generic Structural Differences</h2>
          <p>

            Unlike other generic programming languages, SQL will only deal with databases and so will have a modular structure that will refine searches within a table.
            Other languages will have a more generic structure built of a collection of functions or classes of objects.

          </p>
        </div>

        <div id = "sqlvsjpql">
        <h2 id="para-3">SQL vs JPQL</h2>
        <p>
          Java contains its own query language - Java Persistence Query Language (JPQL) which allows it to use the object orientation
          to be translated and used with relational databases. It does this by transforming the syntax into SQL to handle
          the databases features to complement the contradictory nature of Relational Data and Object Oriented Programming.
          This is because of the differening storing of data. Normalisation breaks down data into its most fine form with
          no redundancies and no non-key dependencies in a tabular tuple based system whereas object oriented program languages
          handle objects and how they reference one another to form a graph connected objects.
        </p>

        <div style="margin-bottom: 50px; margin-top: 50px;">
          <img src="../img/sql_2.png" style="display: block; margin-right: auto; margin-left: auto;">
        </div>

        <p>
          At a first glance SQL looks syntantically the same as JPQL. One of the key differences between raw SQL and JPQL is that JPQL
          deals with objects directly whereas SQL queries only deal with tables directly. This makes the intergration into
          generic programming languages easier. E.g. Lets say we have a Car and we want to store data about specific parts
          of the car such as wheels, chassis and colour. Storing this data in a relational manner:
        </p>
        <br>
        <table>
          <thead>
            <tr>
              <th>Car</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td>CarID</td>
              <td>
                <i>Primary Key</i>
              </td>
            </tr>
            <tr>
              <td>Owner</td>
            </tr>
            <tr>
              <td>...</td>
            </tr>
          </tbody>
        </table>
        <br>
        <table>
          <thead>
            <tr>
              <th>Chassis</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td>ChassisID</td>
              <td>
                <i>Primary Key</i>
              </td>
            </tr>
            <tr>
              <td>CarID</td>
              <td>
                <i>Foreign Key</i>
              </td>
            </tr>
            <tr>
              <td>...</td>
            </tr>
          </tbody>
        </table>
        <p>
          Whereas stored using a object orientated form (Java):
        </p>
        <br>
        <div class = "col-5">
        <pre class = "prettyprint"><code>
            
public Car{

  private Chassis chassis;
  private String owner;

  @Override
  public int hashcode(){
     ...
  }

}

public Chassis{

  private Car car;

  public Chassis(Car car){
    this.car = car;
    ...
  }

  @Override
  public int hashcode(){
     ...
  }

            }
        </code></pre>
      </div>
        <br>
        <br>
        <p>
          When we refer to a table in SQL we use the notation &ltTableName&gt . &ltFieldName&gt. Java uses the notation &ltObject&gt.&ltAttribute&gt
          where the the object reference is an instance of the object if the class is not static. As a result the syntax
          can appear to be the same.
        </p>
        <br>
        <p>In SQL</p>
        <code>
          SELECT Car.Owner FROM Car
         </code>
        <p>In Java</p>
        <code>
          SELECT c.owner FROM Car c
        </code>
        <br>
        <br>
        <p>
          Despite the benefits of JPQL, it does not contain the full range of SQL's functionality - ON, UNION, INTERSECT are some of
          the functions that require third party applications to fulfil all the functionality of SQL.
          As a result, Java also supports the use of SQL as well as JPQL.
          A query is passed directly as String as parameter and returns a object that will contain the results of the query.
        <p>JPQL with Eclipse add-on:</p>
        <code>
            package com.tutorialspoint.eclipselink.service;

            import java.util.List;
            import javax.persistence.EntityManager;
            import javax.persistence.EntityManagerFactory;
            import javax.persistence.Persistence;
            import javax.persistence.Query;
            
            public class JPQLTest {
               public static void main( String[] args ) {
               
                  EntityManagerFactory factory = Persistence.createEntityManagerFactory( "Eclipselink_JPA" );
                  EntityManager entitymanager = factory.createEntityManager();
            
                  //Generates query and retrieves results
                  Query query = entitymanager.createQuery("SELECT c.owner from Car c");
                  List&ltString&gt owners = query.getResultList();
            
                  System.out.println("Owners: ");
                  for(String owner:owners) {
                     System.out.println(owner);
                  }
               }
            }
        </code>
        <p>SQL</p>
        <code>
            import java.sql.*;

            public class SQLTest {           
                public static void main (String[] args) {
                    try {
                        String url = "https://localhost:3330"; //Url of Database
                        Connection connection = DriverManager.getConnection(url,"","");
                        Statement statement = connection.createStatement();
                        ResultSet rs;
             
                        rs = statement.executeQuery("SELECT Onwer.Car from Car");

                        while ( rs.next() ) {
                            String owner = rs.getString("Owner.Car");
                            System.out.println(owner);
                        }
                        connection.close();

                    } catch (Exception e) {
                        System.out.println(e.getMessage());
                    }
                }
            }
        </code>
        <p>
          Although in terms of similar length, as we recall from earlier, the JPQL will have to be translated into an SQL query before being submitted to the database whereas the SQL can be directly queried to the database and requires no modification. 
          As a result when dealing with larger amounts of data, the translation time will need to taken into account when dealing with data unlike SQL and can slow down the effectiveness of JPQL despite its advantages to deal with Objects.
        </p>

      </div>
      <div id = "bigdata">
        <h2 id="para-4">Big Data</h2>
        <p>

          Due to the rapidly increasing role of Big Data and its variety and volume, SQL will contribute more to the handling of this
          data. 
          It is modular in nature and can be deployed to be run on servers to enable parallel processing to occur and
          to minimise the network traffic like other functional programming languages. This allows the analysis of large amounts of data to be completed in a shorter time frame enabling the processing of the data to be more efficent.
          As result of its efficiency, it is widely used in generic programming languages as a package rather than generate its own query module.


        </p>
      </div>
      </div>
    </div>
  </div>
  <script src="https://cdn.rawgit.com/google/code-prettify/master/loader/run_prettify.js?autorun=true&amp;skin=desert"></script>
  <script src="../scripts/article-header.js"></script>
  <script src="../scripts/article-navbar.js"></script>
</body>

</html>
